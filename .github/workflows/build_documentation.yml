name: Continous documentation (build stable docs on tag/release and latest docs on each push)

on:
   push:
     branches:
       - master  
     tags:
       - 'v*'

env:
   DOCUMENT_NAME: TorXakis-TOOLVERSION_Userguide-DOCVERSION 

jobs:
  cancel-previous-latest-builds:
    runs-on: ubuntu-latest
    steps:
      - run: |
          # if building 'stable' documentation for a tag, then don't kill any previous builds running
          # note: 
          #   head_branch:"BRANCH" when pushing commits to BRANCH branch(latest build => older are killed)
          #   head_branch:"TAGLABEL" when pushing a tag. (we want stable release build, therefore not killed)
          REF=${{ github.ref }}
          if [[ $REF == *"tags"* ]]; then
             echo "not killing any previous runs when building a stable documentation for a tagged release"
             exit 0
          fi

          # get branch for 'latest' build    
          BRANCH=${REF##*/}          
          
          #  when building 'latest; documentation when commits are pushed to a BRANCH then kill previous 
          # 'latest' builds. Note: we select below only builds for 'latest' builds to kill, not 'stable' builds.
          
          GITHUB_API="https://api.github.com"
          AUTH_HEADER="Authorization: token ${{ secrets.GITHUB_TOKEN }}"
          
          # get the github workflow ID
          workflow_id=$(curl -s "${GITHUB_API}/repos/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}" -H "${AUTH_HEADER}" |  jq -r '.workflow_id')
          echo "workflow id: $workflow_id"
          
          # get the run ids  for the specific branch 
          jq_run_ids=".workflow_runs | .[] | select(.head_branch==\"${BRANCH}\" and (.status==\"in_progress\" or .status==\"queued\")) | .id"         
          # only kill run ids with lower id value then the current run id (don't kill itself or newer runs)
          run_ids=$(curl -s "${GITHUB_API}/repos/${GITHUB_REPOSITORY}/actions/workflows/${workflow_id}/runs" -H "${AUTH_HEADER}" | jq -r "${jq_run_ids}" | sort -n | sed -e "/$GITHUB_RUN_ID/,\$d")
          echo "run ids: $run_ids"

          # cancel the previous runs
          for run_id in $run_ids
          do
            curl -s -X POST -H "${AUTH_HEADER}" ${GITHUB_API}/repos/${GITHUB_REPOSITORY}/actions/runs/${run_id}/cancel
            echo "Cancelled run $run_id"
          done             
  build:
    runs-on: ubuntu-latest
    steps:
# checkout source of pushed commit or pushed tag
# build pdf and for none-release builds push it online in bashupload for 7 days (for quick review pdf)
# build html with link to pdf document ( released pdf url  or  bashupload url)
# publish html on github pages ( in stable/ subdir for released docs, in latest/ for latest commit push)             
    - name:  checkout source branch 
      uses: actions/checkout@v2   
    - name:  check whether pushing commit or tag, check creating a release is still needed and set DOCUMENT_NAME
      run: |
        REF=${{ github.ref }}
        TOOLVERSION=$(cat source/TOOLVERSION.txt 2>/dev/null) || TOOLVERSION=unknown
        DOCUMENT_NAME=${DOCUMENT_NAME/TOOLVERSION/$TOOLVERSION}
        if [[ $REF == *"tags"* ]]; then
          TAG_NAME=${REF##*/}
          echo "pushing a tag: $TAG_NAME"
          echo "::set-env name=TAG_NAME::$TAG_NAME"
          
          DO_RELEASE="yes"
          WEBSITE_SUBDIR="stable"
          URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG_NAME}"
          StatusCode=$(curl -o -I -L -s -w "%{http_code}" -X GET -G $URL)
          echo $StatusCode
          if [[ "$StatusCode" == 200 ]]; then
             echo "This is tagged release: there exists as github release for this tag."
             CREATE_RELEASE="no"
          else
             echo "This is a tag for which no github release exist."
             CREATE_RELEASE="yes"
          fi
          
          DOCUMENT_NAME=${DOCUMENT_NAME/DOCVERSION/$TAG_NAME}
          DOCUMENT_URL_PDF="https://github.com/${GITHUB_REPOSITORY}/releases/download/${TAG_NAME}/${DOCUMENT_NAME}.pdf" 
          
        else
          BRANCH_NAME=${REF##*/}
          echo "pushing a commit in branch: $BRANCH_NAME"
          echo "::set-env name=BRANCH_NAME::$BRANCH_NAME"
          
          DO_RELEASE="no"
          CREATE_RELEASE="no"
          WEBSITE_SUBDIR="latest"
          
          SHA1=${{ github.sha }}
          SHA1_SHORT=${SHA1:0:7}
          DOCUMENT_NAME=${DOCUMENT_NAME/DOCVERSION/$SHA1_SHORT}
          DOCUMENT_URL_PDF="https://github.com/${GITHUB_REPOSITORY}/releases/download/develop/${DOCUMENT_NAME}.pdf"         
        fi
        
        echo DO_RELEASE=$DO_RELEASE
        echo CREATE_RELEASE=$CREATE_RELEASE
        echo WEBSITE_SUBDIR=$WEBSITE_SUBDIR
        echo "::set-env name=WEBSITE_SUBDIR::$WEBSITE_SUBDIR"
        echo "::set-env name=DO_RELEASE::$DO_RELEASE"
        echo "::set-env name=CREATE_RELEASE::$CREATE_RELEASE"
        
        echo DOCUMENT_NAME=$DOCUMENT_NAME
        echo DOCUMENT_URL_PDF=$DOCUMENT_URL_PDF
        echo "::set-env name=DOCUMENT_NAME::$DOCUMENT_NAME"
        echo "::set-env name=DOCUMENT_URL_PDF::$DOCUMENT_URL_PDF"
    
# sphinx build sets environment variables SPHINX_BUILD_PDF,DOCUMENT_NAME and DOCUMENT_URL_PDF
# because all user config in sphinx config, so that this file can be unchanged
    - name: build documentation pdf in build/latex/ which contains reference to online pdf in $DOCUMENT_URL_PDF (only for tagged builds this URL is set)
      uses: ammaraskar/sphinx-action@0.4
      with:
        pre-build-command: "apt-get update -y && apt-get install -y graphviz git latexmk texlive-latex-recommended texlive-latex-extra texlive-fonts-recommended"
        build-command: "make html latexpdf"
        docs-folder: "."
    # - name: "for none-release build: upload pdf to bashupload.com storage and set bashupload.com's url in env.var. DOCUMENT_URL_PDF (after 1 week is automatically deleted from server)"
    #   if: env.DO_RELEASE == 'no'
    #   run: |
    #     output=$(curl https://bashupload.com/docs.pdf --data-binary @$SPHINX_BUILD_PDF)
    #     DOCUMENT_URL_PDF=https:${output##*https:}?download=1
    #     echo DOCUMENT_URL_PDF=DOCUMENT_URL_PDF
    #     echo "::set-env name=DOCUMENT_URL_PDF::$DOCUMENT_URL_PDF"
    #     echo "DOCUMENT_URL_PDF=$DOCUMENT_URL_PDF"
    # - name: build documentation website in build/html/ which contains reference to online pdf in $DOCUMENT_URL_PDF
    #   uses: ammaraskar/sphinx-action@0.4
    #   with:
    #     pre-build-command: "apt-get update -y && apt-get install -y graphviz git"
    #     build-command: "make html"
    #     docs-folder: "."
    - name: Commit build html documentation to gh-pages branch checkout in gh-pages subdir
      run: |
        # clone gh-pages branch into
        git clone "https://github.com/$GITHUB_REPOSITORY.git" --branch gh-pages --single-branch gh-pages
        rsync -av --delete  build/html/ gh-pages/$WEBSITE_SUBDIR/
        cd gh-pages
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        git commit -m "Update documentation" -a || true
        # The above command will fail if no changes were present, so we ignore that.
    - name: Push changes in gh-pages branch to github
      uses: ad-m/github-push-action@master
      with:
        branch: gh-pages
        directory: gh-pages
        github_token: ${{ secrets.GITHUB_TOKEN }}
# on latest build, delete and  recreate 'develop' release and upload pdf to github releases page     
    - name: Delete old develop release
      if: env.DO_RELEASE == 'no' 
      run: |    
          GITHUB_API="https://api.github.com"
          AUTH_HEADER="Authorization: token ${{ secrets.GITHUB_TOKEN }}"
          RELEASE_ID=$(curl -s -H "${AUTH_HEADER}" "${GITHUB_API}/repos/${GITHUB_REPOSITORY}/releases" |jq -r '.[] | select(.tag_name=="develop") | .id')          
          #DELETE /repos/:owner/:repo/releases/:release_id
          output_delete=$(curl -s -X DELETE -H "${AUTH_HEADER}" "${GITHUB_API}/repos/${GITHUB_REPOSITORY}/releases/${RELEASE_ID}")
          echo $output_delete         
    - name: (Re)Create develop Release
      if: env.DO_RELEASE == 'no'
      #if: always() && env.DO_RELEASE == 'no'
      # https://github.com/actions/create-release
      id: develop_release_info
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 
      with:
        tag_name: develop
        release_name: Latest documentation still under development 
        body: ''
        draft: false
        prerelease: false  
    - name: Upload latest pdf as develop release asset 
      if: env.DO_RELEASE == 'no'
      uses: actions/upload-release-asset@v1.0.1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.develop_release_info.outputs.upload_url }}
        asset_path: ${{ env.SPHINX_BUILD_PDF }}
        asset_name: ${{ env.DOCUMENT_NAME }}.pdf
        asset_content_type: binary/octet-stream                 
# on new tag/release: create release and upload pdf and zipped website to github releases page     
    - name: Create Release
      if: env.CREATE_RELEASE == 'yes'
      # https://github.com/actions/create-release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        body: ''
        draft: false
        prerelease: false    
    - name: Create Web Release Asset
      if: env.DO_RELEASE == 'yes'
      run: |  
        cd build/html/; zip -r ../../website.zip .; cd - 
    - name: Get Release Info to fetch upload_url
      if: env.DO_RELEASE == 'yes'
      id: get_release_info
      uses: bruceadams/get-release@v1.2.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    - name: Upload release asset as pdf 
      if: env.DO_RELEASE == 'yes'
      uses: actions/upload-release-asset@v1.0.1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.get_release_info.outputs.upload_url }}
        asset_path: ${{ env.SPHINX_BUILD_PDF }}
        asset_name: ${{ env.DOCUMENT_NAME }}.pdf
        asset_content_type: binary/octet-stream  
    - name: Upload release asset as zipped html website (.website.zip)
      if: env.DO_RELEASE == 'yes'
      uses: actions/upload-release-asset@v1.0.1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.get_release_info.outputs.upload_url }}
        asset_path: ./website.zip
        asset_name: ${{ env.DOCUMENT_NAME }}.website.zip
        asset_content_type: application/zip         
